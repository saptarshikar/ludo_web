# Ludo Architecture Overview

## Gameplay essentials
- **Setup and token lifecycle:** Each room-backed match seeds its `LudoGame` with colour-coded player configurations, four tokens per seat, and a turn roster derived from the shared constants catalogue. `addPlayer`/`addAiPlayer` attach socket metadata or AI difficulty, allocate fresh token arrays, and build the per-player track path that wraps the 52-square board before diverging into the home stretch.【F:src/domain/constants.js†L1-L23】【F:src/domain/entities/LudoGame.js†L19-L135】
- **Safe squares and captures:** The shared `SAFE_TRACK_POSITIONS` list designates protected indices; when a move resolves onto an unsafe track square, opposing tokens found there are reset to base and the capture is recorded in the rolling history log.【F:src/domain/constants.js†L1-L23】【F:src/domain/entities/LudoGame.js†L339-L358】
- **Home stretch progression:** Player paths concatenate the circular track with six home tiles, preventing overshoot beyond the computed `FINISH_STEP`; finishing moves convert tokens to a terminal state and surface in turn history for UI replay.【F:src/domain/constants.js†L11-L23】【F:src/domain/entities/LudoGame.js†L57-L218】【F:src/domain/entities/LudoGame.js†L325-L362】
- **Victory conditions and pending results:** Once all four tokens for a colour reach the goal, `checkWin` flips the phase to `finished`, persists the winning player id, and stages a `pendingResults` payload (including participant profile ids) for downstream persistence workers.【F:src/domain/entities/LudoGame.js†L364-L476】

## Server turn lifecycle
- **Coordinated player turns:** The `GameCoordinator` mediates dice rolls and token moves, enforcing turn ownership, broadcasting dice results, and advancing or reshuffling the queue as needed. Automated opponents reuse these entry points through `runAiTurns`, which repeatedly executes roll/move steps until the AI’s obligations are satisfied or the game ends.【F:src/application/services/GameCoordinator.js†L217-L311】【F:src/application/services/GameCoordinator.js†L270-L312】
- **Result persistence:** After a win, `persistPendingResults` either publishes a game-result job onto the queue-backed producer or records stats through the MySQL profile repository, ensuring idempotent consumption through the domain event wrapper.【F:src/application/services/GameCoordinator.js†L130-L180】
- **Socket orchestration:** `registerGameSocketHandlers` binds Socket.IO events to the coordinator flows—joining rooms, rolling dice, moving tokens, and triggering AI runs—before emitting refreshed room summaries and full game state snapshots to subscribers. Disconnects feed back into the registry so the same broadcast pipeline cleans up vacated seats.【F:src/interfaces/socket/registerGameSocketHandlers.js†L47-L223】

## Layered architecture
- **Domain layer:** Core game rules live in `LudoGame` (turn state machine, token mutations, win detection) alongside the `GameResultRecorded` event schema that normalises result payloads and idempotency keys.【F:src/domain/entities/LudoGame.js†L19-L476】【F:src/domain/events/GameResultRecorded.js†L1-L75】
- **Service / coordinator layer:** `GameCoordinator` composes the domain model with persistence hooks, AI helpers, and registry lookups to expose application-level commands used by both HTTP and Socket transports.【F:src/application/services/GameCoordinator.js†L115-L312】
- **Room, session, and persistence infrastructure:** The `RoomRegistry` abstracts pluggable stores, defaulting to the in-memory adapter while supporting Redis-backed durability with automatic write-through proxies and pending-write drains; see `rooms.md` for deeper storage schematics.【F:src/infrastructure/rooms/RoomRegistry.js†L1-L45】【F:src/infrastructure/rooms/InMemoryRoomStore.js†L1-L103】【F:src/infrastructure/rooms/RedisRoomStore.js†L1-L235】【F:docs/architecture/rooms.md†L1-L160】 Session tokens default to the in-memory TTL store, while player profile stats persist via the MySQL repository, which also bootstraps schema migrations on demand.【F:src/infrastructure/sessions/InMemorySessionStore.js†L1-L56】【F:src/infrastructure/persistence/MySqlProfileRepository.js†L1-L92】 Queueing components (`GameResultQueue` and `GameResultProducer`) capture result jobs for the persistence worker pipeline.【F:src/infrastructure/messaging/GameResultQueue.js†L1-L97】【F:src/infrastructure/messaging/GameResultProducer.js†L1-L43】
- **Interface adapters:** `createHttpApp` wraps the Express router that exposes health, auth, and config endpoints, while `createGameSocketServer` couples Socket.IO to the coordinator and session stores.【F:src/interfaces/http/createHttpApp.js†L1-L21】【F:src/interfaces/http/createHttpRouter.js†L1-L200】【F:src/interfaces/socket/createGameSocketServer.js†L1-L30】
- **Bootstrap and services:** `createApplicationContext` wires shared dependencies (room store choice, profile repository, messaging queue) that `src/server.js`, `httpService.js`, and `socketService.js` reuse when starting monolithic or split deployments. Environment/Redis utilities and graceful shutdown helpers manage transport lifecycles and draining pending room writes.【F:src/bootstrap/createApplicationContext.js†L1-L69】【F:src/server.js†L1-L67】【F:src/services/httpService.js†L1-L61】【F:src/services/socketService.js†L1-L78】【F:src/bootstrap/loadEnvironmentConfig.js†L1-L47】【F:src/bootstrap/createRedisManager.js†L1-L121】【F:src/bootstrap/createGracefulShutdown.js†L1-L22】
- **Persistence worker pipeline:** Background workers subscribe to the result queue, hydrate domain events, deduplicate via optional repositories, and fan out profile updates while reporting retries/failures to the configured logger.【F:src/workers/persistenceWorker.js†L1-L86】
